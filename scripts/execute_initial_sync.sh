#!/bin/bash

###############################################################################
# Initial Sync Executor
# 
# Purpose: Execute initial synchronization based on comparison results
# Uses: sync_plan CSV generated by compare_libraries.py
#
# This script automates the initial one-time sync between Ali and Chris
# based on the quality comparison analysis
#
# Author: Project Mother
# Last Updated: 2024-12-23
###############################################################################

set -e

# Configuration
SYNC_PLAN_FILE=""
DRY_RUN=true
PARALLEL_TRANSFERS=4
BANDWIDTH_LIMIT=0  # 0 = unlimited, or specify MB/s

# Paths
ALI_BASE="\\\\192.168.1.10\\media"
CHRIS_BASE="/mnt/synology"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

###############################################################################
# Functions
###############################################################################

log() {
    echo -e "${1}"
}

log_info() {
    log "${GREEN}[INFO]${NC} ${1}"
}

log_warn() {
    log "${YELLOW}[WARN]${NC} ${1}"
}

log_error() {
    log "${RED}[ERROR]${NC} ${1}"
}

log_section() {
    log "\n${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    log "${BLUE}${1}${NC}"
    log "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}\n"
}

usage() {
    cat << EOF
Usage: $0 [OPTIONS]

Execute initial synchronization based on comparison results.

Options:
    -f, --file FILE         Sync plan CSV file (required)
    --live                  Execute live sync (default is dry-run)
    -p, --parallel N        Number of parallel transfers (default: 4)
    -b, --bandwidth N       Bandwidth limit in MB/s (default: unlimited)
    -h, --help              Show this help message

Examples:
    # Dry run (recommended first)
    $0 -f sync_plan_20241223.csv

    # Live sync with bandwidth limit
    $0 -f sync_plan_20241223.csv --live -b 50

    # Parallel transfers
    $0 -f sync_plan_20241223.csv --live -p 8

EOF
    exit 0
}

parse_sync_plan() {
    local plan_file=$1
    
    if [ ! -f "$plan_file" ]; then
        log_error "Sync plan file not found: $plan_file"
        exit 1
    fi
    
    log_info "Parsing sync plan: $plan_file"
    
    # Count items
    local total=$(tail -n +2 "$plan_file" | wc -l)
    local ali_to_chris=$(tail -n +2 "$plan_file" | grep -c "Ali → Chris" || true)
    local chris_to_ali=$(tail -n +2 "$plan_file" | grep -c "Chris → Ali" || true)
    
    log_info "Total items: $total"
    log_info "  Ali → Chris: $ali_to_chris"
    log_info "  Chris → Ali: $chris_to_ali"
    
    # Calculate total size (if available in CSV)
    # CSV format: Direction,Title,Filename,Size_GB,Quality_Score,Reason
}

sync_file() {
    local direction=$1
    local filename=$2
    local source=$3
    local dest=$4
    local size_gb=$5
    
    log_info "Syncing: $filename ($size_gb GB)"
    log_info "  From: $source"
    log_info "  To: $dest"
    
    if [ "$DRY_RUN" == "true" ]; then
        log_warn "  [DRY RUN] Would sync this file"
        return 0
    fi
    
    # Determine sync method
    local source_type=$(echo "$source" | cut -d: -f1)
    local dest_type=$(echo "$dest" | cut -d: -f1)
    
    # Build rsync command
    local rsync_opts=(
        "-avhP"  # archive, verbose, human-readable, progress
        "--stats"
        "--timeout=300"
    )
    
    if [ $BANDWIDTH_LIMIT -gt 0 ]; then
        rsync_opts+=("--bwlimit=${BANDWIDTH_LIMIT}M")
    fi
    
    # Execute rsync
    if rsync "${rsync_opts[@]}" "$source" "$dest"; then
        log_info "  ✅ Successfully synced: $filename"
        return 0
    else
        log_error "  ❌ Failed to sync: $filename"
        return 1
    fi
}

process_sync_plan() {
    local plan_file=$1
    
    log_section "Processing Sync Plan"
    
    local line_num=0
    local success_count=0
    local fail_count=0
    local skip_count=0
    
    # Read CSV line by line (skip header)
    while IFS=, read -r direction title filename size_gb quality_score reason; do
        ((line_num++))
        
        # Skip header
        if [ $line_num -eq 1 ]; then
            continue
        fi
        
        log_section "Item $line_num: $title"
        
        # Parse direction and determine paths
        local source=""
        local dest=""
        
        if [[ "$direction" == "Ali → Chris" ]]; then
            # Find file in Ali's library
            # This is a simplified example - you'll need to adapt based on your actual paths
            source="${ALI_BASE}/$(find_file_path "$filename" "$ALI_BASE")"
            dest="${CHRIS_BASE}/$(determine_dest_path "$filename")"
        elif [[ "$direction" == "Chris → Ali" ]]; then
            source="${CHRIS_BASE}/$(find_file_path "$filename" "$CHRIS_BASE")"
            dest="${ALI_BASE}/$(determine_dest_path "$filename")"
        else
            log_warn "Unknown direction: $direction - Skipping"
            ((skip_count++))
            continue
        fi
        
        # Verify source exists
        if [ ! -f "$source" ] && [ "$DRY_RUN" != "true" ]; then
            log_error "Source file not found: $source"
            ((fail_count++))
            continue
        fi
        
        # Sync file
        if sync_file "$direction" "$filename" "$source" "$dest" "$size_gb"; then
            ((success_count++))
        else
            ((fail_count++))
        fi
        
        # Add delay between transfers to prevent overwhelming the network
        if [ "$DRY_RUN" != "true" ]; then
            sleep 2
        fi
        
    done < "$plan_file"
    
    # Summary
    log_section "Sync Summary"
    log "Total items processed: $((line_num - 1))"
    log "Successful: $success_count"
    log "Failed: $fail_count"
    log "Skipped: $skip_count"
}

find_file_path() {
    local filename=$1
    local base_path=$2
    
    # This is a placeholder function
    # You'll need to implement actual file finding logic
    # based on your directory structure
    
    # Example: search for file recursively
    find "$base_path" -name "$filename" -type f 2>/dev/null | head -n 1
}

determine_dest_path() {
    local filename=$1
    
    # Determine destination path based on filename
    # This is simplified - adapt to your actual directory structure
    
    if [[ "$filename" =~ 2160p|4K ]]; then
        if [[ "$filename" =~ S[0-9]+E[0-9]+ ]]; then
            echo "4K TV Shows/"
        else
            echo "4K Movies/"
        fi
    else
        if [[ "$filename" =~ S[0-9]+E[0-9]+ ]]; then
            echo "TV Shows/"
        else
            echo "Movies/"
        fi
    fi
}

confirm_execution() {
    if [ "$DRY_RUN" == "true" ]; then
        log_section "DRY RUN MODE"
        log_warn "This is a DRY RUN - no files will be transferred"
        log_warn "Review the output above to verify the sync plan"
        log_info "To execute for real, use: $0 -f $SYNC_PLAN_FILE --live"
        return 0
    fi
    
    log_section "LIVE SYNC CONFIRMATION"
    log_warn "⚠️  WARNING: This will execute a LIVE sync"
    log_warn "⚠️  Files will be transferred across the network"
    
    read -p "Are you sure you want to proceed? (type 'YES' to confirm): " confirm
    
    if [ "$confirm" != "YES" ]; then
        log_info "Sync cancelled"
        exit 0
    fi
    
    log_info "Proceeding with live sync..."
}

###############################################################################
# Main Script
###############################################################################

main() {
    log_section "Initial Sync Executor Started"
    log "Timestamp: $(date '+%Y-%m-%d %H:%M:%S')"
    
    if [ -z "$SYNC_PLAN_FILE" ]; then
        log_error "Sync plan file not specified"
        usage
    fi
    
    # Parse and display sync plan
    parse_sync_plan "$SYNC_PLAN_FILE"
    
    # Confirm execution
    confirm_execution
    
    # Process sync plan
    process_sync_plan "$SYNC_PLAN_FILE"
    
    log_section "Initial Sync Executor Completed"
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -f|--file)
            SYNC_PLAN_FILE="$2"
            shift 2
            ;;
        --live)
            DRY_RUN=false
            shift
            ;;
        -p|--parallel)
            PARALLEL_TRANSFERS="$2"
            shift 2
            ;;
        -b|--bandwidth)
            BANDWIDTH_LIMIT="$2"
            shift 2
            ;;
        -h|--help)
            usage
            ;;
        *)
            log_error "Unknown option: $1"
            usage
            ;;
    esac
done

# Run main function
main
